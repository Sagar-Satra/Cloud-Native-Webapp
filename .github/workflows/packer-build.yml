name: Packer Build and instance refresh

on:
  pull_request:
    branches:
      - main

jobs:
  packer-build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout the repository
        uses: actions/checkout@v3

      - name: Set up Packer
        uses: hashicorp/setup-packer@v2
      
      
      
      # Commenting the GCP code as we are not using it in this assignment
      # - name: 'google cloud authentication'
      #   uses: google-github-actions/auth@v2
      #   with:
      #       credentials_json: ${{ secrets.GCP_CREDENTIAL }}
  
      # - name: 'Set up GCP SDK'
      #   uses: google-github-actions/setup-gcloud@v2
        
      # - name: 'Set up and use GCP CLI'
      #   run: 'gcloud info'

      # - name: Create /tmp/webapp Directory
      #   run: mkdir -p /tmp/webapp
  
      # - name: Copy Files to /tmp/webapp
      #   run: cp -r $GITHUB_WORKSPACE/* /tmp/webapp/
  
      # - name: List /tmp/webapp Contents
      #   run: ls -lah /tmp/webapp

      # setting the AWS credentials for dev service account 
      - name: Set up AWS CLI for service account in Dev env
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.SERVICE_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.SERVICE_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Initialize Packer (Install required plugins)
        run: packer init ./packer

      - name: Run Packer Build for AWS
        env:
          AMI_Name: ${{ vars.AMI_NAME }}
          Instance_Type: ${{ vars.INSTANCE_TYPE }}
          AWS_Region: ${{ vars.AWS_REGION }}
          Ubuntu_AMI_Image: ${{ vars.UBUNTU_AMI_IMAGE }}
          SSH_User_Name: ${{ vars.UBUNTU_USER_NAME }}

        run: |
          export PACKER_LOG=1
          packer build \
            -var "ami_name1=${{ env.AMI_Name}}" \
            -var "instance_type1=${{ env.Instance_Type }}" \
            -var "aws_region1=${{ env.AWS_Region }}" \
            -var "ubuntu_ami_image1=${{ env.Ubuntu_AMI_Image }}" \
            -var "ssh_username1=${{ env.SSH_User_Name }}" \
            ./packer/aws-ubuntu.pkr.hcl
      
      - name: Get latest AMI ID
        id: get_ami_id
        run: |
          AMI_ID=$(aws ec2 describe-images --owners self --query 'Images[*].[ImageId,CreationDate]' --output text | sort -k2 -r | head -n1 | cut -f1)
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV
          echo "Latest AMI ID: $AMI_ID"
          
          # Validate that we have a non-empty AMI ID
          if [ -z "$AMI_ID" ]; then
            echo "ERROR: Failed to get a valid AMI ID"
            exit 1
          fi
        
      - name: Sharing the AMI with DEMO account
        run: |
          echo "Sharing AMI ${{ env.AMI_ID }} with demo account..."
          aws ec2 modify-image-attribute \
            --image-id ${{ env.AMI_ID }} \
            --launch-permission "Add=[{UserId=${{ secrets.DEMO_AWS_ACCOUNT_ID }}}]"
          
          # Verify the sharing operation succeeded
          SHARED_ACCOUNTS=$(aws ec2 describe-image-attribute \
            --image-id ${{ env.AMI_ID }} \
            --attribute launchPermission \
            --query 'LaunchPermissions[*].UserId' \
            --output text)
            
          if [[ $SHARED_ACCOUNTS == *"${{ secrets.DEMO_AWS_ACCOUNT_ID }}"* ]]; then
            echo "AMI successfully shared with demo account"
          else
            echo "ERROR: Failed to share AMI with demo account"
            exit 1
          fi
      
      # switching to demo account
      - name: Configuring AWS credentials for service account in demo env
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.DEMO_SERVICE_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEMO_SERVICE_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      # waiting for AMI to be available in demo account
      - name: Wait for AMI to be available in demo account
        run: |
          echo "Waiting for AMI to be available in DEMO account..."
          
          RETRY_COUNT=0
          MAX_RETRIES=15
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            AMI_STATE=$(aws ec2 describe-images --image-ids ${{ env.AMI_ID }} --query 'Images[0].State' --output text 2>/dev/null || echo "pending")
            
            echo "Current AMI state: $AMI_STATE (Attempt $RETRY_COUNT of $MAX_RETRIES)"
            
            if [ "$AMI_STATE" = "available" ]; then
              echo "AMI is now available in DEMO account"
              break
            fi
            
            if [ $RETRY_COUNT -eq $((MAX_RETRIES-1)) ]; then
              echo "ERROR: Timed out waiting for AMI to be available"
              exit 1
            fi
            
            echo "AMI not yet available. Waiting 20 seconds..."
            sleep 20
            RETRY_COUNT=$((RETRY_COUNT+1))
          done
      
      # Update Launch Template with new AMI ID
      - name: Update Launch Template
        run: |
          # First list all launch templates to verify what we're working with
          echo "Available Launch Templates:"
          aws ec2 describe-launch-templates --query 'LaunchTemplates[*].[LaunchTemplateId,LaunchTemplateName]' --output table
          
          # Get the Launch Template ID
          echo "Attempting to find Launch Template..."
          LAUNCH_TEMPLATE_ID=$(aws ec2 describe-launch-templates --query 'LaunchTemplates[?LaunchTemplateName==`csye6225_asg`].LaunchTemplateId' --output text)
          echo "Found Launch Template ID: '$LAUNCH_TEMPLATE_ID'"
          
          # Validate the Launch Template ID exists
          if [ -z "$LAUNCH_TEMPLATE_ID" ]; then
            echo "ERROR: No Launch Template found!"
            exit 1
          fi
          
          # Verify the Launch Template exists
          echo "Verifying Launch Template..."
          aws ec2 describe-launch-templates \
            --launch-template-ids "$LAUNCH_TEMPLATE_ID" || {
              echo "ERROR: Invalid Launch Template ID"
              exit 1
            }
          
          # Get the full template data and modify only the AMI ID
          echo "Getting current template data..."
          TEMPLATE_DATA=$(aws ec2 describe-launch-template-versions \
            --launch-template-id $LAUNCH_TEMPLATE_ID \
            --versions '$Latest' \
            --query 'LaunchTemplateVersions[0].LaunchTemplateData' \
            --output json)
          
          # Install jq if needed
          sudo apt-get update && sudo apt-get install -y jq
          
          # Update only the AMI ID
          echo "Updating AMI ID in template data..."
          MODIFIED_DATA=$(echo $TEMPLATE_DATA | jq --arg ami "${{ env.AMI_ID }}" '.ImageId = $ami')
          
          # Create new version with all data preserved
          echo "Creating new launch template version with AMI ID: ${{ env.AMI_ID }}"
          aws ec2 create-launch-template-version \
            --launch-template-id $LAUNCH_TEMPLATE_ID \
            --version-description "Auto-updated AMI via GitHub Actions" \
            --launch-template-data "$MODIFIED_DATA"
            
          # Set the newest version as default
          echo "Setting newest version as default..."
          LATEST_VERSION=$(aws ec2 describe-launch-template-versions \
            --launch-template-id $LAUNCH_TEMPLATE_ID \
            --query 'LaunchTemplateVersions[0].VersionNumber' \
            --output text)
          aws ec2 modify-launch-template \
            --launch-template-id $LAUNCH_TEMPLATE_ID \
            --default-version $LATEST_VERSION
          
          echo "Launch Template updated with new AMI ID: ${{ env.AMI_ID }}"
          
      # Start instance refresh in Auto Scaling Group
      - name: Start Instance Refresh
        id: start-refresh
        run: |
          echo "Starting instance refresh..."
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name app-autoscaling-group \
            --preferences '{"MinHealthyPercentage": 50, "InstanceWarmup": 300}' \
            --query 'InstanceRefreshId' --output text)

          if [ -z "$REFRESH_ID" ]; then
            echo "ERROR: Failed to start instance refresh"
            exit 1
          fi

          echo "REFRESH_ID=$REFRESH_ID" >> $GITHUB_ENV
          echo "Instance refresh started with ID: $REFRESH_ID"

        # Wait for instance refresh to complete (infinite loop)
      - name: Wait for Instance Refresh to Complete
        run: |
          echo "Waiting for instance refresh to complete..."

          while true; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name app-autoscaling-group \
              --instance-refresh-ids ${{ env.REFRESH_ID }} \
              --query 'InstanceRefreshes[0].Status' --output text)
              
            PERCENTAGE=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name app-autoscaling-group \
              --instance-refresh-ids ${{ env.REFRESH_ID }} \
              --query 'InstanceRefreshes[0].PercentageComplete' --output text)

            echo "Status: $STATUS, Percentage complete: $PERCENTAGE%"

            if [ "$STATUS" = "Successful" ]; then
              echo "Instance refresh completed successfully"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ]; then
              echo "ERROR: Instance refresh failed or was cancelled"
              exit 1
            fi

            echo "Sleeping for 30 seconds..."
            sleep 30
          done

        # Verify application is accessible (infinite loop)
      - name: Verify Application Health After Refresh
        run: |
          echo "Verifying application health after instance refresh..."

          LB_DNS=$(aws elbv2 describe-load-balancers \
            --names webapp-load-balancer \
            --query 'LoadBalancers[0].DNSName' \
            --output text)

          if [ -z "$LB_DNS" ]; then
            echo "WARNING: Could not find load balancer DNS name. Skipping health check."
            exit 0
          fi

          echo "Testing application health at http://$LB_DNS/healthz"

          while true; do
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$LB_DNS/healthz")

            if [ "$STATUS_CODE" = "200" ]; then
              echo "Application is healthy and accessible"
              break
            fi

            echo "Application not yet healthy (status $STATUS_CODE), waiting..."
            sleep 30
          done
